{"version":3,"file":"index.js","sources":["src/get-innermost-scope.mjs","src/find-variable.mjs","src/token-predicate.mjs","src/get-function-head-location.mjs","src/get-static-value.mjs","src/get-string-if-constant.mjs","src/get-property-name.mjs","src/get-function-name-with-kind.mjs","src/has-side-effect.mjs","src/is-parenthesized.mjs","src/pattern-matcher.mjs","src/reference-tracker.mjs","src/index.mjs"],"sourcesContent":["/**\n * Get the innermost scope which contains a given location.\n * @param {Scope} initialScope The initial scope to search.\n * @param {Node} node The location to search.\n * @returns {Scope} The innermost scope.\n */\nexport function getInnermostScope(initialScope, node) {\n    const location = node.range[0]\n\n    let scope = initialScope\n    let found = false\n    do {\n        found = false\n        for (const childScope of scope.childScopes) {\n            const range = childScope.block.range\n\n            if (range[0] <= location && location < range[1]) {\n                scope = childScope\n                found = true\n                break\n            }\n        }\n    } while (found)\n\n    return scope\n}\n","import { getInnermostScope } from \"./get-innermost-scope.mjs\"\n\n/**\n * Find the variable of a given name.\n * @param {Scope} initialScope The scope to start finding.\n * @param {string|Node} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.\n * @returns {Variable|null} The found variable or null.\n */\nexport function findVariable(initialScope, nameOrNode) {\n    let name = \"\"\n    let scope = initialScope\n\n    if (typeof nameOrNode === \"string\") {\n        name = nameOrNode\n    } else {\n        name = nameOrNode.name\n        scope = getInnermostScope(scope, nameOrNode)\n    }\n\n    while (scope != null) {\n        const variable = scope.set.get(name)\n        if (variable != null) {\n            return variable\n        }\n        scope = scope.upper\n    }\n\n    return null\n}\n","/**\n * Negate the result of `this` calling.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the result of `this(token)` is `false`.\n */\nfunction negate0(token) {\n    return !this(token) //eslint-disable-line no-invalid-this\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {function(Token):boolean} f - The function to negate.\n * @returns {function(Token):boolean} Negated function.\n */\nfunction negate(f) {\n    return negate0.bind(f)\n}\n\n/**\n * Checks if the given token is a PunctuatorToken with the given value\n * @param {Token} token - The token to check.\n * @param {string} value - The value to check.\n * @returns {boolean} `true` if the token is a PunctuatorToken with the given value.\n */\nfunction isPunctuatorTokenWithValue(token, value) {\n    return token.type === \"Punctuator\" && token.value === value\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nexport function isArrowToken(token) {\n    return isPunctuatorTokenWithValue(token, \"=>\")\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nexport function isCommaToken(token) {\n    return isPunctuatorTokenWithValue(token, \",\")\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nexport function isSemicolonToken(token) {\n    return isPunctuatorTokenWithValue(token, \";\")\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nexport function isColonToken(token) {\n    return isPunctuatorTokenWithValue(token, \":\")\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nexport function isOpeningParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \"(\")\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nexport function isClosingParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \")\")\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nexport function isOpeningBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"[\")\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nexport function isClosingBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"]\")\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nexport function isOpeningBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"{\")\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nexport function isClosingBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"}\")\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nexport function isCommentToken(token) {\n    return [\"Block\", \"Line\", \"Shebang\"].includes(token.type)\n}\n\nexport const isNotArrowToken = negate(isArrowToken)\nexport const isNotCommaToken = negate(isCommaToken)\nexport const isNotSemicolonToken = negate(isSemicolonToken)\nexport const isNotColonToken = negate(isColonToken)\nexport const isNotOpeningParenToken = negate(isOpeningParenToken)\nexport const isNotClosingParenToken = negate(isClosingParenToken)\nexport const isNotOpeningBracketToken = negate(isOpeningBracketToken)\nexport const isNotClosingBracketToken = negate(isClosingBracketToken)\nexport const isNotOpeningBraceToken = negate(isOpeningBraceToken)\nexport const isNotClosingBraceToken = negate(isClosingBraceToken)\nexport const isNotCommentToken = negate(isCommentToken)\n","import { isArrowToken, isOpeningParenToken } from \"./token-predicate.mjs\"\n\n/**\n * Get the `(` token of the given function node.\n * @param {Node} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken)\n}\n\n/**\n * Get the location of the given function node for reporting.\n * @param {Node} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {string} The location of the function node for reporting.\n */\nexport function getFunctionHeadLocation(node, sourceCode) {\n    const parent = node.parent\n    let start = null\n    let end = null\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken)\n\n        start = arrowToken.loc.start\n        end = arrowToken.loc.end\n    } else if (\n        parent.type === \"Property\" ||\n        parent.type === \"MethodDefinition\" ||\n        parent.type === \"PropertyDefinition\"\n    ) {\n        start = parent.loc.start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    } else {\n        start = node.loc.start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    }\n\n    return {\n        start: { ...start },\n        end: { ...end },\n    }\n}\n","/* globals globalThis, global, self, window */\n\nimport { findVariable } from \"./find-variable.mjs\"\n\nconst globalObject =\n    typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof window !== \"undefined\"\n        ? window\n        : typeof global !== \"undefined\"\n        ? global\n        : {}\n\nconst builtinNames = Object.freeze(\n    new Set([\n        \"Array\",\n        \"ArrayBuffer\",\n        \"BigInt\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n        \"Boolean\",\n        \"DataView\",\n        \"Date\",\n        \"decodeURI\",\n        \"decodeURIComponent\",\n        \"encodeURI\",\n        \"encodeURIComponent\",\n        \"escape\",\n        \"Float32Array\",\n        \"Float64A