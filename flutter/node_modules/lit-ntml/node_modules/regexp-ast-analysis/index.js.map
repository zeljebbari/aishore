{"version":3,"file":"index.js","sources":[".out/util.js",".out/chars.js",".out/basic.js",".out/cache.js",".out/to-char-set.js",".out/equal.js",".out/follow.js",".out/next-char.js",".out/longest-prefix.js",".out/determinism.js",".out/reorder.js"],"sourcesContent":["import { CharSet } from \"refa\";\nimport { Chars } from \"./chars\";\nexport function assertNever(value, message) {\n    throw new Error(message || value);\n}\nexport function assertSameParent(alternatives) {\n    let parent = null;\n    for (const a of alternatives) {\n        if (parent === null) {\n            parent = a.parent;\n        }\n        else {\n            if (a.parent !== parent) {\n                throw new Error(\"Expected all alternatives to have the same parent\");\n            }\n        }\n    }\n}\nexport const isReadonlyArray = Array.isArray;\nexport function asReadonlySet(iter) {\n    if (iter instanceof Set) {\n        return iter;\n    }\n    return new Set(iter);\n}\nexport class CharUnion {\n    constructor(empty) {\n        this._exactChars = empty;\n        this._inexactChars = empty;\n    }\n    get char() {\n        return this._exactChars.union(this._inexactChars);\n    }\n    get exact() {\n        // basic idea here is that the union or an exact superset with an inexact subset will be exact\n        return this._exactChars.isSupersetOf(this._inexactChars);\n    }\n    add(char) {\n        if (char.exact) {\n            this._exactChars = this._exactChars.union(char.char);\n        }\n        else {\n            this._inexactChars = this._inexactChars.union(char.char);\n        }\n    }\n    static fromFlags(flags) {\n        return new CharUnion(Chars.empty(flags));\n    }\n    static fromMaximum(maximum) {\n        return new CharUnion(CharSet.empty(maximum));\n    }\n}\nexport function unionInexact(left, right) {\n    const char = left.char.union(right.char);\n    let exact;\n    if (left.exact) {\n        if (right.exact) {\n            exact = true;\n        }\n        else {\n            exact = left.char.isSupersetOf(right.char);\n        }\n    }\n    else {\n        if (right.exact) {\n            exact = right.char.isSupersetOf(left.char);\n        }\n        else {\n            exact = false;\n        }\n    }\n    return { char, exact };\n}\nexport function intersectInexact(left, right) {\n    const char = left.char.intersect(right.char);\n    const exact = (left.exact && right.exact) || char.isEmpty;\n    return { char, exact };\n}\nexport class SetEquivalence {\n    constructor(count) {\n        this.count = count;\n        this._indexes = [];\n        for (let i = 0; i < count; i++) {\n            this._indexes.push(i);\n        }\n    }\n    makeEqual(a, b) {\n        // This works using the following idea:\n        //  1. If the eq set of a and b is the same, then we can stop.\n        //  2. If indexes[a] < indexes[b], then we want to make\n        //     indexes[b] := indexes[a]. However, this means that we lose the\n        //     information about the indexes[b]! So we will store\n        //     oldB := indexes[b], then indexes[b] := indexes[a], and then\n        //     make oldB == a.\n        //  3. If indexes[a] > indexes[b], similar to 2.\n        let aValue = this._indexes[a];\n        let bValue = this._indexes[b];\n        while (aValue !== bValue) {\n            if (aValue < bValue) {\n                this._indexes[b] = aValue;\n                // eslint-disable-next-line no-param-reassign -- x\n                b = bValue;\n                bValue = this._indexes[b];\n            }\n            else {\n                this._indexes[a] = bValue;\n                // eslint-disable-next-line no-param-reassign -- x\n                a = aValue;\n                aValue = this._indexes[a];\n            }\n        }\n    }\n    /**\n     * This returns:\n     *\n     * 1. `eqSet.count`: How many different equivalence classes there are.\n     * 2. `eqSet.indexes`: A map (array) from each element (index) to the index\n     *    of its equivalence class.\n     *\n     * All equivalence class indexes `eqSet.indexes[i]` are guaranteed to\n     * be <= `eqSet.count`.\n     */\n    getEquivalenceSets() {\n        let counter = 0;\n        for (let i = 0; i < this.count; i++) {\n            if (i === this._indexes[i]) {\n                this._indexes[i] = counter++;\n            }\n            else {\n                this._indexes[i] = this._indexes[this._indexes[i]];\n            }\n        }\n        return {\n            count: counter,\n            indexes: this._indexes,\n        };\n    }\n}\n","/* eslint-disable @typescript-eslint/no-namespace */\nimport { CharSet, JS } from \"refa\";\n/**\n * A set of functions to get predefined character sets.\n */\nexport var Chars;\n(function (Chars) {\n    const EMPTY_UTF16_CHARSET = CharSet.empty(65535 /* UTF16 */);\n    const EMPTY_UNICODE_CHARSET = CharSet.empty(1114111 /* UNICODE */);\n    /**\n     * Returns the empty character set for the given flags.\n     */\n    function empty(flags) {\n        if (flags.unicode) {\n            return EMPTY_UNICODE_CHARSET;\n        }\n        else {\n            return EMPTY_UTF16_CHARSET;\n        }\n    }\n    Chars.empty = empty;\n    const ALL_UTF16_CHARSET = CharSet.all(65535 /* UTF16 */);\n    const ALL_UNICODE_CHARSET = CharSet.all(1114111 /* UNICODE */);\n    /**\n     * Returns the full character set for the given flags.\n     */\n    function all(flags) {\n        if (flags.unicode) {\n            return ALL_UNICODE_CHARSET;\n        }\n        else {\n            return ALL_UTF16_CHARSET;\n        }\n    }\n    Chars.all = all;\n    const LINE_TERMINATOR_UTF16_CHARSET = JS.createCharSet([{ kind: \"any\" }], { unicode: false }).negate();\n    const LINE_TERMINATOR_UNICODE_CHARSET = JS.createCharSet([{ kind: \"any\" }], { unicode: true }).negate();\n    /**\n     * Returns the character set that contains only line terminators.\n     *\n     * This character set accepts all characters that the JS RegExp `.` rejects. The returned character set accepts\n     * all character that the regex `/^.$/` rejects.\n     */\n    function lineTerminator(flags) {\n        if (flags.unicode) {\n            return LINE_TERMINATOR_UNICODE_CHARSET;\n        }\n        else {\n            return LINE_TERMINATOR_UTF16_CHARSET;\n        }\n    }\n    Chars.lineTerminator = lineTerminator;\n    const WORD_UTF16_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], { unicode: false });\n    const WORD_UNICODE_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], {\n        unicode: true,\n        ignoreCase: false,\n    });\n    const WORD_UNICODE_IGNORE_CASE_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], {\n        unicode: true,\n        ignoreCase: true,\n    });\n    /**\n     * Returns a character set that is equivalent to `\\w` with the given flags.\n     *\n     * Note: `\\w` is somewhat special because it has 3 values. All predefined character sets only have two values - one\n     * for Unicode mode and one for non-Unicode mode. This is because Unicode-mode changes the semantics of ignore case\n     * as well. This causes some of the ASCII letters to be ignore-case-equal to higher Unicode characters\n     * (e.g. K (Latin Capital Letter K, U+004b) == k (Latin Small Letter K, U+006b) == â„ª (Kelvin Sign, U+212A)). As a\n     * result `\\w` has 3 values: one for non-Unicode mode, one for case-sensitive Unicode-mode, and one for\n     * case-insensitive Unicode-mode.\n     */\n    function word(flags) {\n        if (flags.unicode) {\n            if (flags.ignoreCase) {\n                return WORD_UNICODE_IGNORE_CASE_CHARSET;\n            }\n            else {\n                return WORD_UNICODE_CHARSET;\n            }\n        }\n        else {\n            return WORD_UTF16_CHARSET;\n        }\n    }\n    Chars.word = word;\n    const DIGIT_UTF16_CHARSET = JS.createCharSet([{ kind: \"digit\", negate: false }], { unicode: false });\n    const DIGIT_UNICODE_CHARSET = JS.createCharSet([{ kind: \"digit\", negate: false }], { unicode: true });\n    /**\n     * Returns a character set that is equivalent to `\\d` with the given flags.\n     */\n    function digit(flags) {\n        if (flags.unicode) {\n            return DIGIT_UNICODE_CHARSET;\n        }\n        else {\n            return DIGIT_UTF16_CHARSET;\n        }\n    }\n    Chars.digit = digit;\n    const SPACE_UTF16_CHARSET = JS.createCharSet([{ kind: \"space\", negate: false }], { unicode: false });\n    const SPACE_UNICODE_CHARSET = JS.createCharSet([{ kind: \"space\", negate: false }], { unicode: true });\n    /**\n     * Returns a character set that is equivalent to `\\s` with the given flags.\n     */\n    function space(flags) {\n        if (flags.unicode) {\n            return SPACE_UNICODE_CHARSET;\n        }\n        else {\n            return SPACE_UTF16_CHARSET;\n        }\n    }\n    Chars.space = space;\n})(Chars || (Chars = {}));\n","import { visitRegExpAST } from \"@eslint-community/regexpp\";\nimport { assertNever, isReadonlyArray } from \"./util\";\nfunction isInvokeEvery(element, fn) {\n    if (isReadonlyArray(element)) {\n        return element.every(fn);\n    }\n    else {\n        return fn(element);\n    }\n}\nfunction isInvokeSome(element, fn) {\n    if (isReadonlyArray(element)) {\n        return element.some(fn);\n    }\n    else {\n        return fn(element);\n    }\n}\n/**\n * Returns whether all (but at least one of the) paths of the given element do not consume characters.\n *\n * If this function returns `true`, then {@link isPotentiallyZeroLength} is guaranteed to return `true`.\n *\n * ## Backreferences\n *\n * This function uses the same condition for backreferences as {@link isEmpty}.\n *\n * ## Relations\n *\n * - `isZeroLength(e) -> isPotentiallyZeroLength(e)`\n * - `isZeroLength(e) -> getLengthRange(e).max == 0`\n *\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isZeroLength(element) {\n    return isInvokeEvery(element, isZeroLengthImpl);\n}\nfunction isZeroLengthImpl(element) {\n    switch (element.type) {\n        case \"Alternative\":\n            return element.elements.every(isZeroLengthImpl);\n        case \"Assertion\":\n            return true;\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return false;\n        case \"Quantifier\":\n            return element.max === 0 || isZeroLengthImpl(element.element);\n        case \"Backreference\":\n            return isEmptyBackreference(element);\n        case \"CapturingGroup\":\n        case \"Group\":\n            return element.alternatives.length > 0 && element.alternatives.every(isZeroLengthImpl);\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether at least one path of the given element does not consume characters.\n *\n * ## Backreferences\n *\n * This function uses the same condition for backreferences as {@link isPotentiallyEmpty}.\n *\n * ## Relations\n *\n * - `isPotentiallyZeroLength(e) -> getLengthRange(e).min == 0`\n *\n * @see {@link isZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isPotentiallyZeroLength(element) {\n    return isInvokeSome(element, e => isPotentiallyZeroLengthImpl(e, e));\n}\nfunction isPotentiallyZeroLengthImpl(e, root) {\n    return impl(e);\n    function impl(element) {\n        switch (element.type) {\n            case \"Alternative\":\n                return element.elements.every(impl);\n            case \"Assertion\":\n                return true;\n            case \"Backreference\":\n                return backreferenceIsPotentiallyEmpty(element, root);\n            case \"Character\":\n            case \"CharacterClass\":\n            case \"CharacterSet\":\n                return false;\n            case \"CapturingGroup\":\n            case \"Group\":\n                return element.alternatives.some(impl);\n            case \"Quantifier\":\n                return element.min === 0 || impl(element.element);\n            default:\n                throw assertNever(element);\n        }\n    }\n}\n/**\n * Returns whether all (but at least one of the) paths of the given element do neither consume characters nor assert\n * characters.\n *\n * If this function returns `true`, then {@link isZeroLength} and {@link isPotentiallyEmpty} are guaranteed to return\n * `true`.\n *\n * ## Backreferences\n *\n * A backreferences will only be considered potentially empty, iff it is empty by the definition of\n * {@link isEmptyBackreference}.\n *\n * ## Relations\n *\n * - `isEmpty(e) -> isZeroLength(e)`\n * - `isEmpty(e) -> isPotentiallyEmpty(e)`\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isEmpty(element) {\n    return isInvokeEvery(element, isEmptyImpl);\n}\nfunction isEmptyImpl(element) {\n    switch (element.type) {\n        case \"Alternative\":\n            return element.elements.every(isEmptyImpl);\n        case \"Assertion\":\n            return false;\n        case \"Backreference\":\n            return isEmptyBackreference(element);\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return false;\n        case \"CapturingGroup\":\n        case \"Group\":\n            return element.alternatives.length > 0 && element.alternatives.every(isEmptyImpl);\n        case \"Quantifier\":\n            return element.max === 0 || isEmptyImpl(element.element);\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether at least one path of the given element does neither consume characters nor assert characters.\n *\n * ## Backreferences\n *\n * A backreferences will only be considered potentially empty, iff at least one of the following conditions is true:\n *\n * - The backreference is trivially always empty. (see {@link isEmptyBackreference})\n * - The referenced capturing group is a descendant of the given element and at least one of the following conditions is\n *   true:\n *   * The referenced capturing group is potentially zero-length.\n *   * The backreferences is not always after its referenced capturing group.\n *     (see {@link isStrictBackreference})\n *\n * ## Relations\n *\n * - `isPotentiallyEmpty(e) -> isPotentiallyZeroLength(e)`\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link getLengthRange}\n */\nexport function isPotentiallyEmpty(element) {\n    return isInvokeSome(element, isPotentiallyEmptyImpl);\n}\nfunction isPotentiallyEmptyImpl(root) {\n    return impl(root);\n    function impl(element) {\n        switch (element.type) {\n            case \"Alternative\":\n                return element.elements.every(impl);\n            case \"Assertion\":\n                return false;\n            case \"Backreference\":\n                return backreferenceIsPotentiallyEmpty(element, root);\n            case \"Character\":\n            case \"CharacterClass\":\n            case \"CharacterSet\":\n                return false;\n            case \"CapturingGroup\":\n            case \"Group\":\n                return element.alternatives.some(impl);\n            case \"Quantifier\":\n                return element.min === 0 || impl(element.element);\n            default:\n                throw assertNever(element);\n        }\n    }\n}\nfunction backreferenceIsPotentiallyEmpty(back, root) {\n    if (isEmptyBackreference(back)) {\n        return true;\n    }\n    else if (hasSomeAncestor(back.resolved, a => a === root)) {\n        return !isStrictBackreference(back) || isPotentiallyZeroLengthImpl(back.resolved, root);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Returns whether any of the ancestors of the given node fulfills the given condition.\n *\n * If the given condition is an AST node instead of a function, `hasSomeAncestor` will behave as if the condition\n * function was `d => d === conditionNode`.\n *\n * The ancestors will be iterated in the order from closest to farthest.\n * The condition function will not be called on the given node.\n */\nexport function hasSomeAncestor(node, condition) {\n    if (typeof condition === \"function\") {\n        return hasSomeAncestorFnImpl(node, condition);\n    }\n    else {\n        return hasSomeAncestorNodeImpl(node, condition);\n    }\n}\nfunction hasSomeAncestorNodeImpl(node, condition) {\n    let parent = node.parent;\n    while (parent) {\n        if (parent === condition) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction hasSomeAncestorFnImpl(node, condition) {\n    let parent = node.parent;\n    while (parent) {\n        if (condition(parent)) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns whether any of the descendants of the given node fulfill the given condition.\n *\n * The descendants will be iterated in a DFS top-to-bottom manner from left to right with the first node being the\n * given node.\n *\n * If the given condition is an AST node instead of a function, `hasSomeDescendant` will behave as if the condition\n * function was `d => d === conditionNode`.\n *\n * This function is short-circuited, so as soon as any `condition` returns `true`, `true` will be returned.\n *\n * @param node\n * @param condition\n * @param descentConditionFn An optional function to decide whether the descendant of the given node will be checked as\n * well.\n *\n * This function will be called with some node only after `condition` has returned `false` for this node.\n */\nexport function hasSomeDescendant(node, condition, descentConditionFn) {\n    if (typeof condition === \"function\") {\n        return hasSomeDescendantImpl(node, condition, descentConditionFn);\n    }\n    else {\n        if (descentConditionFn) {\n            return hasSomeDescendantImpl(node, d => d === condition, descentConditionFn);\n        }\n        else {\n            // instead of checking the O(n) descendant nodes of `node`, we can instead check the O(log n) ancestor\n            // nodes of `condition`\n            return node === condition || hasSomeAncestor(condition, node);\n        }\n    }\n}\nfunction hasSomeDescendantImpl(node, conditionFn, descentConditionFn) {\n    if (conditionFn(node)) {\n        return true;\n    }\n    if (descentConditionFn && !descentConditionFn(node)) {\n        return false;\n    }\n    switch (node.type) {\n        case \"Alternative\":\n            return node.elements.some(e => hasSomeDescendantImpl(e, conditionFn, descentConditionFn));\n        case \"Assertion\":\n            if (node.kind === \"lookahead\" || node.kind === \"lookbehind\") {\n                return node.alternatives.some(a => hasSomeDescendantImpl(a, conditionFn, descentConditionFn));\n            }\n            return false;\n        case \"CapturingGroup\":\n        case \"Group\":\n        case \"Pattern\":\n            return node.alternatives.some(a => hasSomeDescendantImpl(a, conditionFn, descentConditionFn));\n        case \"CharacterClass\":\n            return node.elements.some(e => hasSomeDescendantImpl(e, conditionFn, descentConditionFn));\n        case \"CharacterClassRange\":\n            return (hasSomeDescendantImpl(node.min, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.max, conditionFn, descentConditionFn));\n        case \"Quantifier\":\n            return hasSomeDescendantImpl(node.element, conditionFn, descentConditionFn);\n        case \"RegExpLiteral\":\n            return (hasSomeDescendantImpl(node.pattern, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.flags, conditionFn, descentConditionFn));\n    }\n    return false;\n}\n/**\n * Returns the one-based number of the given capturing group.\n *\n * This is the number needed to refer to the capturing group via backreferences.\n */\nexport function getCapturingGroupNumber(group) {\n    let found = 0;\n    try {\n        visitRegExpAST(getPattern(group), {\n            onCapturingGroupEnter(node) {\n                found++;\n                if (node === group) {\n                    // throw an error to end early\n                    throw new Error();\n                }\n            },\n        });\n        throw new Error(\"Unable to find the given capturing group in its parent pattern.\");\n    }\n    catch (error) {\n        return found;\n    }\n}\n/**\n * Returns the pattern node of the JS RegExp of a given node.\n *\n * This operation is guaranteed to always success for all node types except for flags nodes. Flags nodes have an\n * optional `parent` which, if not set, means that this function can't access the pattern node. If the function can't\n * access the pattern node from a flags node, an error will be thrown.\n */\nexport function getPattern(node) {\n    switch (node.type) {\n        case \"RegExpLiteral\":\n            return node.pattern;\n        case \"Pattern\":\n            return node;\n        case \"Flags\":\n            if (node.parent) {\n                return node.parent.pattern;\n            }\n            else {\n                throw new Error(\"Unable to find the pattern of flags without a RegExp literal.\");\n            }\n        default: {\n            let p = node.parent;\n            while (p.type !== \"Pattern\") {\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n}\n/**\n * Returns the direction which which the given node will be matched relative to the closest parent alternative.\n *\n * If the given node is a lookaround, then the result of `getMatchingDirection(lookaround)` will be the same as\n * `getMatchingDirection(lookaround.parent)`.\n */\nexport function getMatchingDirection(node) {\n    let closestLookaround;\n    hasSomeAncestor(node, a => {\n        if (a.type === \"Assertion\") {\n            closestLookaround = a;\n            return true;\n        }\n        return false;\n    });\n    if (closestLookaround === undefined) {\n        // left-to-right matching is assumed\n        return \"ltr\";\n    }\n    else if (closestLookaround.kind === \"lookahead\") {\n        return \"ltr\";\n    }\n    else {\n        return \"rtl\";\n    }\n}\n/**\n * Returns the opposite matching direction of the given matching direction.\n *\n * If `ltr` is given, `rtl` will be returned and vise versa.\n */\nexport function invertMatchingDirection(direction) {\n    return direction === \"ltr\" ? \"rtl\" : \"ltr\";\n}\n/**\n * Converts a given assertion kind into a matching direction.\n *\n * For lookaheads and lookbehinds, the returned matching direction will be the matching direction of their children.\n * I.e. the result of `lookahead` is `ltr` and the result of `lookbehind` is `rtl`.\n *\n * For edge assertions (`^` and `$`), the returned value is the direction of the character the edge assertion asserts.\n * I.e. the result of `^` is `rtl` (because it asserts the previous character) and the result of `$` is `ltr` (because\n * it asserts the next character).\n */\nexport function getMatchingDirectionFromAssertionKind(kind) {\n    return kind === \"end\" || kind === \"lookahead\" ? \"ltr\" : \"rtl\";\n}\n/**\n * Returns whether the given backreference will always be replaced with the empty string.\n *\n * There are two reasons why a backreference might always be replaced with the empty string:\n *\n * 1. The referenced capturing group does not consume characters.\n *\n *    This is the trivial case. If the referenced capturing group never consumes any characters, then a backreference to\n *    that group must be replaced with the empty string.\n *\n *    E.g. `/(\\b)a\\1/`\n *\n * 2. The backreference is not after the referenced capturing group.\n *\n *    A backreference can only be replaced with a non-empty string if the referenced capturing group has captured text\n *    before the backreference is matched. There are multiple reasons why the capturing group might be unable to capture\n *    text before a backreference to it is reached.\n *\n *    - The capturing group might be in a different alternative. E.g. `/(a)b|\\1/`.\n *    - The backreference might be *inside* the capturing group. E.g. `/(a\\1)/`.\n *    - The backreference might be before the capturing group. E.g. `/\\1(a)/`, `/(?:\\1(a))+/`, `/(?<=(a)\\1)b/`\n */\nexport function isEmptyBackreference(backreference) {\n    const group = backreference.resolved;\n    const closestAncestor = getClosestAncestor(backreference, group);\n    if (closestAncestor === group) {\n        // if the backreference is element of the referenced group\n        return true;\n    }\n    if (closestAncestor.type !== \"Alternative\") {\n        // if the closest common ancestor isn't an alternative => they're disjunctive.\n        return true;\n    }\n    const backRefAncestors = new Set();\n    for (let a = backreference; a; a = a.parent) {\n        backRefAncestors.add(a);\n    }\n    // Now for the hard part:\n    // If there exists a path through the regular expression which connect the group and the backreference, then\n    // the backreference can capture the group iff we only move up, down, or right relative to the group.\n    function findBackreference(node) {\n        const parent = node.parent;\n        switch (parent.type) {\n            case \"Alternative\": {\n                // if any elements right to the given node contain or are the backreference, we found it.\n                const index = parent.elements.indexOf(node);\n                // we have to take the current matching direction into account\n                let next;\n                if (getMatchingDirection(node) === \"ltr\") {\n                    // the next elements to match will be right to the given node\n                    next = parent.elements.slice(index + 1);\n                }\n                else {\n                    // the next elements to match will be left to the given node\n                    next = parent.elements.slice(0, index);\n                }\n                if (next.some(e => backRefAncestors.has(e))) {\n                    return true;\n                }\n                // no luck. let's go up!\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    // can't go up.\n                    return false;\n                }\n                else if (parentParent.type === \"Assertion\" && parentParent.negate) {\n                    // The captured text of a capturing group will be reset after leaving a negated lookaround\n                    return false;\n                }\n                else {\n                    return findBackreference(parentParent);\n                }\n            }\n            case \"Quantifier\":\n                return findBackreference(parent);\n        }\n    }\n    return !findBackreference(group) || isZeroLength(group);\n}\n/**\n * Returns whether the given backreference is a strict backreference.\n *\n * Strict backreferences are backreferences that are always matched __after__ the referenced group was matched. If there\n * exists any path that goes through a backreference but not through the referenced capturing group, that backreference\n * is not strict.\n *\n * ## Examples\n *\n * In the follow examples, `\\1` is a strict backreference:\n *\n * - `/(a)\\1/`\n * - `/(a)(?:b|\\1)/`\n * - `/(a)\\1?/`\n * - `/(?<=\\1(a))b/`\n *\n * In the follow examples, `\\1` is not a strict backreference:\n *\n * - `/(a)|\\1/`\n * - `/(?:(a)|b)\\1/`\n * - `/(a)?\\1/`\n * - `/(?<=(a)\\1)b/`\n * - `/(?!(a)).\\1/`\n */\nexport function isStrictBackreference(backreference) {\n    const group = backreference.resolved;\n    const closestAncestor = getClosestAncestor(backreference, group);\n    if (closestAncestor === group) {\n        // if the backreference is element of the referenced group\n        return false;\n    }\n    if (closestAncestor.type !== \"Alternative\") {\n        // if the closest common ancestor isn't an alternative => they're disjunctive.\n        return false;\n    }\n    const backRefAncestors = new Set();\n    for (let a = backreference; a; a = a.parent) {\n        backRefAncestors.add(a);\n    }\n    function findBackreference(node) {\n        const parent = node.parent;\n        switch (parent.type) {\n            case \"Alternative\": {\n                // if any elements right to the given node contain or are the backreference, we found it.\n                const index = parent.elements.indexOf(node);\n                // we have to take the current matching direction into account\n                let next;\n                if (getMatchingDirection(node) === \"ltr\") {\n                    // the next elements to match will be right to the given node\n                    next = parent.elements.slice(index + 1);\n                }\n                else {\n                    // the next elements to match will be left to the given node\n                    next = parent.elements.slice(0, index);\n                }\n                if (next.some(e => backRefAncestors.has(e))) {\n                    return true;\n                }\n                // no luck. let's go up!\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    // can't go up.\n                    return false;\n                }\n                else if (parentParent.type === \"Assertion\" && parentParent.negate) {\n                    // The captured text of a capturing group will be reset after leaving a negated lookaround\n                    return false;\n                }\n                else {\n                    if (parentParent.alternatives.length > 1) {\n                        // e.g.: (?:a|(a))+b\\1\n                        return false;\n                    }\n                    return findBackreference(parentParent);\n                }\n            }\n            case \"Quantifier\":\n                if (parent.min === 0) {\n                    // e.g.: (a+)?b\\1\n                    return false;\n                }\n                return findBackreference(parent);\n        }\n    }\n    return findBackreference(group);\n}\n/**\n * Returns whether the given node contains or is a capturing group.\n *\n * This function is guaranteed to behave in the same way as:\n *\n * ```js\n * hasSomeDescendant(node, d => d.type === \"CapturingGroup\")\n * ```\n */\nexport function containsCapturingGroup(node) {\n    return hasSomeDescendant(node, isCapturingGroup);\n}\nfunction isCapturingGroup(node) {\n    return node.type === \"CapturingGroup\";\n}\nconst ZERO_LENGTH_RANGE = { min: 0, max: 0 };\nconst ONE_LENGTH_RANGE = { min: 1, max: 1 };\n/**\n * Returns how many characters the given element can consume at most and has to consume at least.\n *\n * Note that character classes are not parsed by this function and are assumed to be non-empty.\n *\n * ## Backreferences\n *\n * While {@link isPotentiallyZeroLength} generally assumes the worst-case for backreferences that references capturing group\n * outside the given element, this function does not/cannot. The length range of a backreference only depends on the\n * referenced capturing group and the relative positions of the backreference and the 