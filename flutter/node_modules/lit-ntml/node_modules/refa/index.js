"use strict";function m(m){function n(a){let i=n.cache.get(a);return void 0===i&&n.cache.set(a,i=m(a)),i}return n.cache=new Map,n}Object.defineProperty(exports,"__esModule",{value:!0});const n=Array.isArray;function a(m,n){let a=0;for(let i=0;i<m.length;i++){const x=m[i];n(x,m[i-a-1])?m[i-a]=x:a++}m.splice(m.length-a,a)}function i(m,n){n===m.length-1?m.pop():m[n]=m.pop()}function x(m,n){let a,i=1/0;for(const x of m){const m=n(x);m<i&&(a=x,i=m)}return a}function e(m){return Array.isArray(m)?m:[...m]}function t(m){return m instanceof Set?m:new Set(m)}function r(m){for(const n of m)return n}function s(m,n){const a=new Set,i=[{element:m,nextIndex:-1}];for(;i.length>0;){const m=i[i.length-1];-1===m.nextIndex&&(a.add(m.element),m.nextElements=e(n(m.element)));const x=m.nextElements;if(!x)throw new Error("This should not happen.");if(m.nextIndex++,m.nextIndex>=x.length){i.pop();continue}const t=x[m.nextIndex];a.has(t)||i.push({element:t,nextIndex:-1})}}function*o(m,n){const a=new Set;let i=[...m],x=[];for(;i.length>0;){for(const m of i)a.has(m)||(a.add(m),yield m,x.push(...n(m)));[i,x]=[x,i],x.length=0}}function l(m,n){const a=new Set,i=[m];let x;for(;i.length;)x=i.pop(),a.has(x)||(a.add(x),n(x,i))}function c(m,n){const a=new Set,i=[...m];let x;for(;i.length;)x=i.pop(),a.has(x)||(a.add(x),n(x,i))}function h(m,n){const a=new Error(n);throw a.data=m,a}function*u(m){for(const n of m)yield*n}function*f(m){for(const n of _(m)){const m=[];for(const a of n)m.push(...a);yield m}}function*p(m){for(const n of _(m))yield[...n]}class d{constructor(m){this._cache=[],this._fullyCached=!1,this._iterator=m[Symbol.iterator]()}[Symbol.iterator](){return this._fullyCached?this._cache[Symbol.iterator]():function*(m){const{_cache:n,_iterator:a}=m;let i=0;for(;!m._fullyCached;)if(i<n.length)yield n[i],i++;else{const x=a.next();if(x.done)m._fullyCached=!0;else{const{value:m}=x;n.push(m),yield m,i++}}for(;i<n.length;i++)yield n[i]}(this)}}function g(m){return Array.isArray(m)||m instanceof Set||m instanceof d?m:new d(m)}function*_(m){const n=e(m).map(g),a=n.map((m=>m[Symbol.iterator]())),i=[];for(const m of a){const n=m.next();if(n.done)return;i.push(n.value)}if(yield i,0!==a.length)for(;;){for(let m=a.length-1;m>=0;m--){const x=a[m].next();if(!x.done){i[m]=x.value;break}if(0===m)return;{a[m]=n[m][Symbol.iterator]();const x=a[m].next();if(x.done)throw new Error;i[m]=x.value}}yield i}}function y(m,n){S(m,n)}function S(m,n){switch(m.type){case"Concatenation":if(null===n)throw new Error("The parent of a concatenation cannot be null.");switch(n.type){case"Alternation":case"Assertion":case"Expression":case"Quantifier":m.parent=n;break;case"Concatenation":throw new Error("A concatenation cannot be parent of a concatenation.");default:throw h(n)}m.elements.forEach((n=>S(n,m)));break;case"Alternation":case"Assertion":case"CharacterClass":case"Quantifier":case"Unknown":if(null===n)throw new Error(`The parent of a(n) ${m.type} cannot be null.`);if("Concatenation"!==n.type)throw new Error(`A(n) ${n.type} cannot be parent of a(n) ${m.type}.`);m.parent=n,"CharacterClass"!==m.type&&"Unknown"!==m.type&&m.alternatives.forEach((n=>S(n,m)));break;case"Expression":if(null!==n)throw new Error(`The parent of an expression has to be null and cannot be a(n) ${n.type}.`);m.parent=null,m.alternatives.forEach((n=>S(n,m)));break;default:throw h(m)}}function C(m,n,a){if("function"!=typeof n){const{start:m,end:a}=n;n=()=>({start:m,end:a})}v(m,n,a)}function v(m,n,a){if(a||!m.source)m.source=n();else{const{start:a,end:i}=m.source;n=()=>({start:a,end:i})}switch(m.type){case"Concatenation":m.elements.forEach((m=>v(m,n,a)));break;case"Alternation":case"Assertion":case"Expression":case"Quantifier":m.alternatives.forEach((m=>v(m,n,a)));break;case"CharacterClass":case"Unknown":break;default:throw h(m)}}function w(m,n){const a=n["on"+m.type+"Enter"];switch(a&&a(m),m.type){case"Alternation":case"Assertion":case"Expression":case"Quantifier":for(const a of m.alternatives)w(a,n);break;case"Concatenation":for(const a of m.elements)w(a,n)}const i=n["on"+m.type+"Leave"];i&&i(m)}const N=["onAlternation","onAssertion","onCharacterClass","onConcatenation","onExpression","onQuantifier"];function k(m){var n;const a={};for(const i of m)for(const m of N){const x=i[m];if(x){(a[m]=null!==(n=a[m])&&void 0!==n?n:[]).push(x.bind(i))}}function i(m){const n=a[m];return void 0===n||0===n.length?void 0:1===n.length?n[0]:function(m,a){for(const i of n)i(m,a)}}return{onAlternation:i("onAlternation"),onAssertion:i("onAssertion"),onCharacterClass:i("onCharacterClass"),onConcatenation:i("onConcatenation"),onExpression:i("onExpression"),onQuantifier:i("onQuantifier"),onUnknown:i("onUnknown")}}function O(m,n,a){var i;let x=null!==(i=(a=null!=a?a:{}).maxPasses)&&void 0!==i?i:10;const e={transformer:m,ast:n,maxCharacter:E(n)};for(;x>=1&&b(e);x--);return n}function E(m){try{return w(m,{onCharacterClassEnter(m){throw m.characters.maximum}}),0}catch(m){if("number"==typeof m)return m;throw m}}function b({transformer:m,ast:n,maxCharacter:a}){let i=!1;const x={maxCharacter:a,signalMutation(){i=!0}};function e(n){const a="on"+n.type,i=m[a];i&&i(n,x)}return w(n,{onAlternationLeave:e,onAssertionLeave:e,onCharacterClassLeave:e,onConcatenationLeave:e,onExpressionLeave:e,onQuantifierLeave:e,onUnknownLeave:e}),i}const A=new Map,J=new Map;class I{get isEmpty(){return 0===this.ranges.length}get isAll(){return 1===this.ranges.length&&0===this.ranges[0].min&&this.ranges[0].max===this.maximum}get size(){let m=0;for(let n=0,a=this.ranges.length;n<a;n++){const{min:a,max:i}=this.ranges[n];m+=i-a+1}return m}constructor(m,n){this.maximum=m,this.ranges=n}characters(){return function(m){const n=function(m,n){if(m.length>n)return;const a=[];for(const{min:i,max:x}of m){if(a.length+x-i>=n)return;for(let m=i;m<=x;m++)a.push(m)}return a}(m,8);if(n)return n;return{[Symbol.iterator](){let n=0,a=m[0].min-1;function i(){n>=m.length||(a++,a>m[n].max&&(n++,n<m.length&&(a=m[n].min)))}return{next:()=>(i(),n>=m.length?{done:!0,value:void 0}:{done:!1,value:a})}}}}(this.ranges)}toString(){return`CharSet (${this.maximum}) [${this.toRangesString()}]`}toRangesString(){let m="";for(const{min:n,max:a}of this.ranges)""!==m&&(m+=", "),m+=n===a?n.toString(16):n.toString(16)+".."+a.toString(16);return m}toUnicodeString(){if(this.isEmpty)return"empty";if(this.isAll)return"all";const m=z(this.ranges);if(m.includes("U+")){const n=z(this.negate().ranges),a=j(n,"U+");if(0===a||a<=j(m,"U+")/2)return"not "+n}return m}static empty(m){let n=A.get(m);return void 0===n&&(n=new I(m,[]),A.set(m,n)),n}static all(m){let n=J.get(m);return void 0===n&&(n=new I(m,[{min:0,max:m}]),J.set(m,n)),n}static fromCharacters(m,n){const a=function(m){const n=[];let a,i=0;for(const x of m)if(void 0===a)a=x,i=1;else{const m=a+i;if(x===m)i++;else if(x>m)n.push({min:a,max:m-1}),a=x,i=1;else if(x!==m-1)throw new RangeError("The character iterable has to be sorted.")}void 0!==a&&n.push({min:a,max:a+i-1});return n}(n);if(0===a.length)return I.empty(m);const i=a[a.length-1];if(i.max>m)throw new RangeError(`The character iterable contained the char ${i.max} but all chars have to be <= maximum=${m}.`);return 1===a.length&&0===i.min&&i.max===m?I.all(m):new I(m,a)}static fromRange(m,n){if(n.max>m)throw new RangeError(`The range [min=${n.min}, max=${n.max}] contains characters greater than the maximum=${m}.`);return new I(m,[n])}equals(m){if(!(m instanceof I))return 1===this.ranges.length&&this.ranges[0].min===m.min&&this.ranges[0].max===m.max;if(m===this)return!0;if(this.maximum!==m.maximum)return!1;if(this.ranges.length!==m.ranges.length)return!1;for(let n=0,a=this.ranges.length;n<a;n++){const a=this.ranges[n],i=m.ranges[n];if(a.min!==i.min||a.max!==i.max)return!1}return!0}compare(m){if(m===this)return 0;if(this.maximum!==m.maximum)return this.maximum-m.maximum;if(this.isEmpty)return m.isEmpty?0:-1;if(m.isEmpty)return 1;if(this.ranges[0].min!==m.ranges[0].min)return this.ranges[0].min-m.ranges[0].min;if(this.ranges.length!==m.ranges.length)return this.ranges.length-m.ranges.length;for(let n=0,a=this.ranges.length;n<a;n++){const a=this.ranges[n],i=m.ranges[n];if(a.min!==i.min)return a.min-i.min;if(a.max!==i.max)return a.max-i.max}return 0}resize(m){if(0===this.ranges.length)return I.empty(m);if(m===this.maximum)return this;if(m>this.maximum)return new I(m,this.ranges);if(this.ranges[this.ranges.length-1].max<=m)return new I(m,this.ranges);{const n=M(this.ranges,[{min:0,max:m}]);return 0===n.length?I.empty(m):new I(m,n)}}negate(){return new I(this.maximum,function(m,n){if(0===m.length)return[{min:0,max:n}];{const a=[],i=m[0],x=m[m.length-1];i.min>0&&a.push({min:0,max:i.min-1});for(let n=1;n<m.length;n++)a.push({min:m[n-1].max+1,max:m[n].min-1});return x.max<n&&a.push({min:x.max+1,max:n}),a}}(this.ranges,this.maximum))}union(...m){const n=m[0];if(1===m.length&&n instanceof I)return P(this,n),0===n.ranges.length?this:new I(this.maximum,function(m,n){const a=[];let i=0,x=0,e=m[i],t=n[x];for(;e&&t;)e.min<=t.min?(a.push(e),e=m[++i]):(a.push(t),t=n[++x]);for(;e;e=m[++i])a.push(e);for(;t;t=n[++x])a.push(t);return T(a),a}(this.ranges,n.ranges));const a=this.ranges.slice();for(const n of m)if(n instanceof I)P(this,n),a.push(...n.ranges);else for(const m of n){if(m.max>this.maximum)throw new RangeError(`max=${m.max} has to be <= maximum=${this.maximum}.`);a.push(m)}var i;return(i=a).sort(((m,n)=>m.min-n.min)),T(i),new I(this.maximum,a)}intersect(m){let n;return m instanceof I?(P(this,m),n=M(this.ranges,m.ranges)):n=M(this.ranges,[m]),0===n.length?I.empty(this.maximum):new I(this.maximum,n)}without(m){let n;return m instanceof I?(P(this,m),n=F(this.ranges,m.ranges)):n=F(this.ranges,[m]),0===n.length?I.empty(this.maximum):new I(this.maximum,n)}has(m){return L(this.ranges,m,m)}isSupersetOf(m){if(!(m instanceof I))return L(this.ranges,m.min,m.max);const n=this.ranges,a=m.ranges;let i=0,x=0,e=n[i],t=a[x];for(;e&&t;)if(e.min<=t.min&&e.max>=t.max)t=a[++x];else{if(!(e.max<t.min))return!1;e=n[++i]}return!t}isSubsetOf(m){return m instanceof I?m.isSupersetOf(this):!!this.isEmpty||m.min<=this.ranges[0].min&&this.ranges[this.ranges.length-1].max<=m.max}isProperSupersetOf(m){return this.isSupersetOf(m)&&!this.equals(m)}isProperSubsetOf(m){return this.isSubsetOf(m)&&!this.equals(m)}isDisjointWith(m){return void 0===this.commonCharacter(m)}commonCharacter(m){if(!(m instanceof I))return function(m,n,a){const i=m.length;if(0==i)return;if(a<m[0].min||n>m[i-1].max)return;let x=0,e=i;for(;x<e;){const i=x+(e-x>>1),t=m[i],r=t.min;if(r==n)return n;if(r<n){if(n<=t.max)return n;x=i+1}else{if(r<=a)return r;e=i}}return}(this.ranges,m.min,m.max);const n=this.ranges,a=m.ranges;let i=0,x=0,e=n[i],t=a[x];for(;e&&t;)if(t.max<e.min)t=a[++x];else{if(!(e.max<t.min))return Math.max(e.min,t.min);e=n[++i]}}}function P(m,n){if(n.maximum!==m.maximum)throw new RangeError(`The maximum of the other set (${n.maximum}) has to be equal the maximum of this set (${m.maximum}).`)}function L(m,n,a){const i=m.length;if(0==i)return!1;if(n<m[0].min||a>m[i-1].max)return!1;if(1==i)return!0;let x=0,e=i;for(;x<e;){const i=x+(e-x>>1),t=m[i],r=t.min;if(r==n)return a<=t.max;if(r<n){if(a<=t.max)return!0;x=i+1}else e=i}return!1}function M(m,n){const a=[];let i=0,x=0,e=m[i],t=n[x];for(;e&&t;)e.max<t.min?e=m[++i]:t.max<e.min?t=n[++x]:(a.push({min:Math.max(e.min,t.min),max:Math.min(e.max,t.max)}),e.max<t.max?e=m[++i]:(t.max<e.max||(e=m[++i]),t=n[++x]));return a}function F(m,n){const a=[];let i=0,x=0,e=m[i],t=n[x];for(;e&&t;)e.max<t.min?(a.push(e),e=m[++i]):t.max<e.min?t=n[++x]:e.min<t.min?(a.push({min:e.min,max:t.min-1}),t.max<e.max?(e={min:t.max+1,max:e.max},t=n[++x]):e=m[++i]):e.max>t.max?(e={min:t.max+1,max:e.max},t=n[++x]):e=m[++i];for(;e;e=m[++i])a.push(e);return a}function T(m){let n=0;for(let a=0,i=m.length-1;a<i;a++){const i=m[a-n],x=m[a+1];i.max>=x.max?n++:x.min<=i.max+1?(m[a-n]={min:i.min,max:x.max},n++):m[a-n+1]=x}n&&(m.length=m.length-n)}function D(m){return"U+"+m.toString(16).toUpperCase()}const B=[{min:48,max:57},{min:65,max:90},{min:97,max:122}];function G(m,n){for(const a of B)if(a.min<=m&&n<=a.max)return!0;return!1}const U=/^[\p{L}\p{Number}]$/u,V=/^[\p{P}\p{Math}]$/u;function R(m){const n=String.fromCodePoint(m);return U.test(n)?n:V.test(n)?"'"+n+"'":D(m)}function z(m){let n="";for(const{min:a,max:i}of m)""!==n&&(n+=" "),a===i?n+=R(a):a+1===i?n+=R(a)+" "+R(i):G(a,i)?n+=String.fromCodePoint(a)+"-"+String.fromCodePoint(i):n+=D(a)+"-"+D(i);return n}function j(m,n){let a=0;for(let i=0;;){const x=m.indexOf(n,i);if(-1===x)break;a++,i=x+n.length}return a}class W{constructor(m){this.sets=function(m){const n=[...t(m)].filter((m=>!m.isEmpty)).sort(((m,n)=>m.compare(n))).filter(((m,n,a)=>0===n||!m.equals(a[n-1])));if(0===n.length)return n;if(1===n.length)return n;const a=n[0].maximum,i=[];for(const m of n){if(m.maximum!==a)throw new RangeError("The maximum of all given sets has to be the same.");i.push(...m.ranges)}const x=I.empty(a).union(i),e=new Set;for(let m=0,n=i.length;m<n;m++){const{min:n,max:a}=i[m];e.add(n),e.add(a+1)}const r=[...e].sort(((m,n)=>m-n)),s=new Map;for(let m=1,a=r.length;m<a;m++){const a=r[m-1];if(x.has(a)){let i="";for(let m=0;m<n.length;m++){n[m].has(a)&&(i+=m+" ")}const x=s.get(i),e={min:a,max:r[m]-1};x?x.push(e):s.set(i,[e])}}const o=[];for(const m of s.values())o.push(I.empty(a).union(m));return o}(m)}split(m){const n=[];for(let a=0,i=this.sets.length;a<i;a++)m.has(this.sets[a].ranges[0].min)&&n.push(a);return n}}class H{constructor(){this._array=[]}get isEmpty(){return 0===this._array.length}_indexOf(m){let n=0,a=this._array.length;for(;n<a;){const i=n+(a-n>>2),x=this._array[i].range;if(m<x.min)a=i;else{if(!(m>x.max))return i;n=i+1}}}_indexOfOrLeft(m){let n=0,a=this._array.length;for(;n<a;){const i=n+(a-n>>2),x=this._array[i].range;if(m<x.min)a=i;else{if(!(m>x.max))return i;if(i+1===this._array.length||m<this._array[i+1].range.min)return i;n=i+1}}}_indexOfOrRight(m){if(0===this._array.length)return;const n=this._indexOfOrLeft(m);return void 0===n?0===this._array.length?void 0:0:m>this._array[n].range.max?n+1<this._array.length?n+1:void 0:n}_indexInRange(m){const n=this._indexOfOrRight(m.min);if(void 0===n)return;const a=this._indexOfOrLeft(m.max);return void 0===a||a<n?void 0:{start:n,stop:a}}_insert(m,n){if(0===this._array.length||this._array[this._array.length-1].range.max+1<m.min)return void this._array.push({range:m,value:n});const a=this._indexOfOrLeft(m.min);if(void 0===a){const a=this._array[0];return void(a.range.min===m.max+1&&a.value===n?a.range={min:m.min,max:a.range.max}:this._array.unshift({range:m,value:n}))}const i=a+1;if(i===this._array.length){const i=this._array[a];return void(i.range.max===m.min-1&&i.value===n?i.range={min:i.range.min,max:m.max}:this._array.push({range:m,value:n}))}const x=this._array[a],e=this._array[i];e.range.min===m.max+1&&e.value===n?x.range.max===m.min-1&&x.value===n?(x.range={min:x.range.min,max:e.range.max},this._array.splice(i,1)):e.range={min:m.min,max:e.range.max}:x.range.max===m.min-1&&x.value===n?x.range={min:x.range.min,max:m.max}:this._array.splice(i,0,{range:m,value:n})}has(m){return void 0!==this._indexOf(m)}hasEvery(m){const n=this._indexInRange(m);if(!n)return!1;for(let m=n.start;m<n.stop;m++)if(this._array[m].range.max+1!==this._array[m+1].range.min)return!1;return!0}hasSome(m){return void 0!==this._indexInRange(m)}get(m){const n=this._indexOf(m);return void 0!==n?this._array[n].value:void 0}set(m,n){this.delete(m),this._insert({min:m,max:m},n)}setRange(m,n){this.deleteRange(m),this._insert(m,n)}setCharSet(m,n){if(this._array.length>0)for(const n of m.ranges)this.deleteRange(n);if(0===this._array.length)for(const a of m.ranges)this._array.push({range:a,value:n});else for(const a of m.ranges)this._insert(a,n)}delete(m){const n=this._indexOf(m);if(void 0===n)return!1;{const a=this._array[n];return a.range.min===a.range.max?this._array.splice(n,1):a.range.min===m?a.range={min:a.range.min+1,max:a.range.max}:a.range.max===m?a.range={min:a.range.min,max:a.range.max-1}:this._array.splice(n,1,{range:{min:a.range.min,max:m-1},value:a.value},{range:{min:m+1,max:a.range.max},value:a.value}),!0}}deleteRange(m){const n=this._indexInRange(m);if(n)if(n.start===n.stop){const a=this._array[n.start];m.min<=a.range.min&&a.range.max<=m.max?this._array.splice(n.start,1):a.range.min<m.min&&m.max<a.range.max?(this._array.splice(n.start+1,0,{range:{min:m.max+1,max:a.range.max},value:a.value}),a.range={min:a.range.min,max:m.min+1}):m.max<a.range.max?a.range={min:m.max+1,max:a.range.max}:a.range={min:a.range.min,max:m.min-1}}else{const a=this._array[n.start];a.range.min<m.min&&(a.range={min:a.range.min,max:m.min-1},n.start++);const i=this._array[n.stop];i.range.max>m.max&&(i.range={min:m.max+1,max:i.range.max},n.stop--),this._array.splice(n.start,n.stop-n.start+1)}}clear(){this._array=[]}map(m){for(const n of this._array)n.value=m(n.value,n.range,this);a(this._array,((m,n)=>!n||n.range.max+1!==m.range.min||n.value!==m.value||(n.range={min:n.range.min,max:m.range.max},!1)))}mapRange(m,n){const a=[];function i(m,n){if(void 0===n)return;const i=a[a.length-1];i&&i.range.max+1===m.min&&i.value===n?i.range={min:i.range.min,max:m.max}:a.push({range:m,value:n})}const x=this._array.length;if(0===x)i(m,n(void 0,m,this));else{const a=this._array[0],e=a.range.min,t=this._array[x-1].range.max;if(!(m.min<=e&&t<=m.max))throw new Error("Partial range maps aren't supported yet");if(m.min<e){const a={min:m.min,max:e-1};i(a,n(void 0,a,this))}i(a.range,n(a.value,a.range,this));for(let m=1;m<x;m++){const a=this._array[m-1],x=this._array[m],e={min:a.range.max+1,max:x.range.min-1};e.min<=e.max&&i(e,n(void 0,e,this)),i(x.range,n(x.value,x.range,this))}if(t<m.max){const a={min:t+1,max:m.max};i(a,n(void 0,a,this))}}this._array=a}filter(m){a(this._array,(n=>m(n.value,n.range,this)))}invert(m){const n=new Map;for(const{range:m,value:a}of this._array){let i=n.get(a);void 0===i&&n.set(a,i=[]),i.push(m)}const a=new Map;for(const[i,x]of n)a.set(i,I.empty(m).union(x));return a}forEach(m){for(const n of this._array)m(n.value,n.range,this)}*keys(){for(const{range:m}of this._array)yield m}*values(){for(const{value:m}of this._array)yield m}*entries(){for(const{range:m,value:n}of this._array)yield[m,n]}[Symbol.iterator](){return this.entries()}}function Q(n,a,i,x){const e=m((m=>I.fromCharacters(x,[m])));for(const m of i){let i=n.initial;for(const t of m){if(t>x)throw new Error(`The character (${t}) has to be <= maxCharacter (${x}).`);let m=a(i,t);void 0===m&&(m=n.createNode(),n.linkNodes(i,m,e(t))),i=m}n.makeFinal(i)}return{initial:n.initial,stableOut:!0,getOut:m=>m,isFinal:m=>n.isFinal(m)}}function K(m,n,a){const i=new q(m.initial);for(const x of n){let n=new Set([i]);for(const i of x){if(i.maximum!==a)throw new Error(`The maximum (${i.maximum}) of the char set has to be == maxCharacter (${a}).`);const x=new Set;for(const a of n)for(const n of a.getNext(i,m))x.add(n);n=x}for(const m of n)m.isFinal=!0}return l(i,((n,a)=>{n.isFinal&&m.makeFinal(n.builderNode);for(const{to:i,via:x}of n.out)a.push(i),m.linkNodes(n.builderNode,i.builderNode,x)})),{initial:m.initial,stableOut:!0,getOut:m=>m,isFinal:n=>m.isFinal(n)}}class ${constructor(m,n){this.to=m,this.via=n}}class q{constructor(m){this.out=[],this.isFinal=!1,this.builderNode=m}copy(m){const n=new q(m.createNode());n.isFinal=this.isFinal;for(const{to:a,via:i}of this.out)n.out.push(new $(a.copy(m),i));return n}getNext(m,n){const a=[],i=[];for(let x=0,e=this.out.length;x<e;x++){const e=this.out[x];if(e.via.isDisjointWith(m));else if(e.via.isSubsetOf(m))i.push(e.via),a.push(e.to);else{const x=new $(e.to.copy(n),e.via.intersect(m));this.out.push(x),e.via=e.via.without(m),i.push(x.via),a.push(x.to)}}const x=0===i.length?m:m.without(I.empty(m.maximum).union(...i));if(!x.isEmpty){const m=new $(new q(n.createNode()),x);this.out.push(m),a.push(m.to)}return a}}function Z(m,n,a=!1){return{initial:m.initial,getOut:n,stableOut:a,isFinal:m.isFinal}}function X(m,n){return{initial:m.initial,getOut:m.getOut,stableOut:m.stableOut,isFinal:n}}function Y(m,n){const a=m.getOut;return Z(m,(m=>n(a(m))))}function mm(m,n){const a=m.getOut;return Z(m,(function*(m){for(const i of a(m))yield n(i)}))}function nm(m,n){const a=m.getOut;return Z(m,(function*(m){for(const i of a(m))n(i)&&(yield i)}))}function am(m,n){l(m.initial,n?(a,i)=>{n(a),i.push(...m.getOut(a))}:(n,a)=>{a.push(...m.getOut(n))})}function im(m){return m.stableOut?m:function(m){const n=new Map,a=m.getOut;return Z(m,(m=>{let i=n.get(m);return void 0===i&&(i=a(m),n.set(m,i)),i}),!0)}(m)}function xm(m){const{initial:n,getOut:a}=m;return o([n],a)}function em(m){const{isFinal:n}=m;for(const a of xm(m))if(n(a))return!0;return!1}function tm(m){const{initial:n,getOut:a}=m,i=new Set,x=new Set([n]),t=[{element:n,nextIndex:-1}];for(;t.length>0;){const m=t[t.length-1];-1===m.nextIndex&&(x.add(m.element),i.add(m.element),m.nextElements=e(a(m.element)));const n=m.nextElements;if(m.nextIndex++,m.nextIndex>=n.length){x.delete(m.element),t.pop();continue}const r=n[m.nextIndex];if(x.has(r))return!0;i.has(r)||t.push({element:r,nextIndex:-1})}return!1}function rm(m){const n=[...xm(m=im(Y(m,e)))],a=n.filter(m.isFinal),i=function(m,n){const a=new Map;for(const n of m)a.set(n,new Set);for(const i of m)for(const m of n(i))a.get(m).add(i);return a}(n,m.getOut),x=new Set(o(a,(m=>i.get(m))));return!tm(nm(m,(m=>x.has(m))))}function sm(m,n){const{initial:a,getOut:i,isFinal:x}=m;if(x(a))return[];const e=new Map;function t(m){const n=[];for(;;){const a=e.get(m);if(null===a)return n.reverse();n.push(a.item),m=a.from}}e.set(m.initial,null);let r=[m.initial];for(;r.length>0;){const m=[];for(const a of r)for(const r of i(a)){const i=n(r);if(!e.has(i)){if(e.set(i,{item:r,from:a}),x(i))return t(i);m.push(i)}}r=m}}function om(m,n,a){n=im(n),a=im(a);const i=lm(),x=lm();n.isFinal(n.initial)&&a.isFinal(a.initial)&&m.makeFinal(m.initial);const e=new Map;e.set(m.initial,[n.initial,a.initial]);const t={[`${i(n.initial)};${x(a.initial)}`]:m.initial};function r(r,s){const o=i(r)+";"+x(s);let l=t[o];return void 0===l&&(l=m.createNode(),t[o]=l,e.set(l,[r,s]),n.isFinal(r)&&a.isFinal(s)&&m.makeFinal(l)),l}const s=function(){const m={},n=new Map;function a(a){let i=n.get(a);if(void 0===i){let x=function(m){let n=65535&m.maximum;return m.ranges.forEach((({min:m,max:a})=>{n=65535&(31*n+m^31*a)})),n}(a);for(;;){const e=m[x];if(void 0===e){m[x]=a,i=n.size;break}if(e.equals(a)){i=n.get(e);break}x=x+1&65535}n.set(a,i)}return i}const i={};return(m,n)=>{const x=a(m),e=a(n);if(x==e)return m;let t;t=x<e?x+";"+e:e+";"+x;let r=i[t];return void 0===r&&(r=m.intersect(n),r.isEmpty&&(r=null),i[t]=r),r}}();function o(i){const x=function(m){const n=e.get(m);if(void 0===n)throw new Error("All created nodes have to be indexed.");return n}(i),t=n.getOut(x[0]),o=a.getOut(x[1]);for(const[n,a]of t)for(const[x,e]of o){const t=s(a,e);t&&m.linkNodes(i,r(n,x),t)}}return{initial:m.initial,getOut:m=>(o(m),m),isFinal:n=>m.isFinal(n)}}function lm(){const m=new Map;return n=>{let a=m.get(n);return void 0===a&&(a=m.size,m.set(n,a)),a}}function cm(m,n){n=im(n);const{charSets:i,ids:x}=function(m){const n=new Set,a=new Map;let i=0;return l(m.initial,((x,e)=>{a.set(x,i),i++;for(const[a,i]of m.getOut(x))n.add(i),e.push(a)})),{charSets:n,ids:a}}(n),e=new W(i),t=new Map,r=new Map;function s(m){let n="";for(let a=0,i=m.length;a<i;a++)n+=","+x.get(m[a]);return n}function o(i,e){const o=[];for(const m of i)for(const[a,i]of n.getOut(m))i.has(e)&&o.push(a);return 0===o.length?void 0:function(i){i.sort(((m,n)=>x.get(m)-x.get(n))),a(i,((m,n)=>m!==n));const e=s(i);let o=t.get(e);return void 0===o&&(o=m.createNode(),i.some((m=>n.isFinal(m)))&&m.makeFinal(o),t.set(e,o),r.set(o,i)),o}(o)}return t.set(s([n.initial]),m.initial),r.set(m.initial,[n.initial]),n.isFinal(n.initial)&&m.makeFinal(m.initial),{initial:m.initial,getOut:n=>{const a=(i=n,r.get(i));var i;for(const i of e.sets){const x=o(a,i.ranges[0].min);void 0!==x&&m.linkNodes(n,x,i)}return n},isFinal:n=>m.isFinal(n)}}class hm extends Error{static assert(m,n,a){let i=m,x=n;if("number"!=typeof i&&(i=i.maxCharacter),"number"!=typeof x&&(x=x.maxCharacter),i!==x)throw new hm(void 0!==a?`The two ${a} do not have the same max character. ${i} != ${x}`:`Different max character. ${i} != ${x}`)}}class um extends Error{static assert(m,n,a){if(m>n)throw new um(`The ${a} is not allowed to create more than ${n} nodes.`)}}class fm{constructor(m=1/0){this._counter=0,this.initial=new Map,this.finals=new Set,this._limit=m}makeFinal(m){this.finals.add(m)}isFinal(m){return this.finals.has(m)}createNode(){return um.assert(++this._counter,this._limit,"MapFABuilder"),new Map}linkNodes(m,n,a){const i=m.get(n);void 0===i?m.set(n,a):m.set(n,i.union(a))}}function pm(m,n){const{initial:a,getOut:i,isFinal:x}=im(m),e=new Map;function t(m){const a=e.get(m);if(void 0!==a)return a;if(x(m))return e.set(m,!0),!0;const t=new Map,r=new Set([m]);let s=[m];for(;s.length>0;){const m=[];for(let a=0,o=s.length;a<o;a++){const o=s[a];for(const a of i(o)){const i=n(a);let s=t.get(i);if(void 0===s&&(s=[],t.set(i,s)),s.push(o),r.has(i))continue;r.add(i);const l=e.get(i);if(!0===l||x(i))return dm(e,i,t),!0;!1!==l&&m.push(i)}}s=m}return r.forEach((m=>e.set(m,!1))),!1}return{initial:a,getOut:function(m){const a=[];for(const x of i(m))t(n(x))&&a.push(x);return a},isFinal:x}}function dm(m,n,a){var i;m.set(n,!0);let x=[n];for(;x.length>0;){const n=[];for(let e=0,t=x.length;e<t;e++){const t=x[e];null===(i=a.get(t))||void 0===i||i.forEach((a=>{m.has(a)||(m.set(a,!0),n.push(a))}))}x=n}}function gm(m){const n=im(Y(m,e)),a=[...xm(mm(n,(([m])=>m)))],i=new Map(a.map(((m,n)=>[m,n])));return{stableIter:n,states:a,info:{isInitial:m=>m===n.initial,isFinal:n.isFinal,getId:m=>i.get(m),getNumberOfOutgoingEdges:m=>n.getOut(m).length}}}function _m(m,n){const{getEdgeAttributes:a,getGraphAttributes:i=Sm,getNodeAttributes:x=ym}="transitionToString"in n?function({transitionToString:m,ordered:n=!1}){return{getEdgeAttributes(a,i,x,e,t){const r={label:m(a)};return n&&t.getNumberOfOutgoingEdges(x)>1&&(r.taillabel=String(i+1)),r}}}(n):n,{stableIter:e,states:t,info:r}=gm(m);let s="";function o(m){if(/^[a-zA-Z_]\w*$/.test(m))s+=m;else{let n=m.replace(/[\\"]/g,(m=>"\\"+m));"\\"===n[n.length-1]&&(n+=" "),s+='"'+n+'"'}}function l(m){if("number"==typeof m){const n=String(m);/^-?(?:\.\d+|\d+(?:\.\d*)?)$/.test(n)?s+=n:o(n)}else o(m)}function c(m){s+="[";let n=!0;for(const a in m)if(Object.prototype.hasOwnProperty.call(m,a)){const i=m[a];if(void 0===i)continue;n?n=!1:s+=", ",o(a),s+="=",l(i)}s+="]"}function h(m){s+="n"+m}s+="digraph ",s+="{\n",s+="\t// graph attributes\n";const u=i();for(const m in u)if(Object.prototype.hasOwnProperty.call(u,m)){const n=u[m];if(void 0===n)continue;s+="\t",o(m),s+="=",l(n),s+=";\n"}return s+="\n\t// nodes\n",s+="\tnull [shape=point];\n",t.forEach(((m,n)=>{s+="\t",h(n),s+=" ",c(x(m,r)),s+=";\n"})),s+="\n\t// edges\n",s+="\tnull -> n0;\n",t.forEach(((m,n)=>{e.getOut(m).forEach((([i,x],e)=>{s+="\t",h(n),s+=" -> ",function(m){s+="n"+r.getId(m)}(i),s+=" ",c(a(x,e,m,i,r)),s+=";\n"}))})),s+="}",s}const ym=(m,n)=>({label:String(n.getId(m)),shape:n.isFinal(m)?"doublecircle":"circle"}),Sm=()=>({rankdir:"LR"});function Cm(m,n){const{getEdgeAttributes:a,getNodeAttributes:i=vm}="transitionToString"in n?function({transitionToString:m,ordered:n=!1}){return{getEdgeAttributes(a,i,x,e,t){let r=m(a),s=1;return n&&t.getNumberOfOutgoingEdges(x)>1&&(r=`(${i+1}) ${r}`,s=i+1),{label:r,length:s}}}}(n):n,{stableIter:x,states:e,info:t}=gm(m);let r="";function s(m){0===m.length?r+=" ":/^\w+$/.test(m)?r+=m:r+='"'+m.replace(/"/g,"&quot")+'"'}function o(m){r+="n"+m}return r+="flowchart LR\n",r+="%% nodes\n",r+="\tnull(( ))\n",e.forEach(((m,n)=>{r+="\t",o(n),function(m){r+=m.shape[0],s(m.label),r+=m.shape[1]}(i(m,t)),r+="\n"})),r+="\n%% edges\n",r+="\tnull -.-> n0\n",e.forEach(((m,n)=>{x.getOut(m).forEach((([i,x],e)=>{var l,c;r+="\t",o(n),r+=" ",l=a(x,e,m,i,t),r+="-".repeat((null!==(c=l.length)&&void 0!==c?c:1)+1)+">",void 0!==l.label&&(r+="|",s(l.label),r+="|"),r+=" ",function(m){r+="n"+t.getId(m)}(i),r+="\n"}))})),r.trim()}const vm=(m,n)=>({label:String(n.getId(m)),shape:n.isFinal(m)?["(((",")))"]:["((","))"]});function wm(m){if(Array.isArray(m))return m.every(wm);switch(m.type){case"Alternation":case"Expression":return wm(m.alternatives);case"Assertion":return!0;case"CharacterClass":case"Unknown":return!1;case"Concatenation":return m.elements.every(wm);case"Quantifier":return 0===m.max||wm(m.alternatives);default:h(m)}}function Nm(m){if(Array.isArray(m))return m.every(Nm);switch(m.type){case"Alternation":case"Expression":return Nm(m.alternatives);case"Assertion":return Om(m);case"CharacterClass":case"Unknown":return!1;case"Concatenation":return m.elements.every(Nm);case"Quantifier":return 0===m.max||Nm(m.alternatives);default:h(m)}}function km(m){if(Array.isArray(m))return m.some(km);switch(m.type){case"Alternation":case"Expression":return km(m.alternatives);case"Assertion":return Om(m);case"CharacterClass":case"Unknown":return!1;case"Concatenation":return m.elements.every(km);case"Quantifier":return 0===m.min||km(m.alternatives);default:h(m)}}function Om(m){return m.negate?0===m.alternatives.length:km(m.alternatives)}function Em(m,n,a){if(n(m))return!0;if(a&&!a(m))return!1;switch(m.type){case"Alternation":case"Expression":case"Assertion":case"Quantifier":return m.alternatives.some((m=>Em(m,n,a)));case"Concatenation":return m.elements.some((m=>Em(m,n,a)))}return!1}function bm(m,n){return new Am([...m,n])}class Am{constructor(m){if(this.stack=m,"Expression"!==m[0].type)throw new Error("Invalid stack")}get node(){return this.stack[this.stack.length-1]}toParentPath(){return this.stack.pop(),0===this.stack.length?null:this}toChildPath(m){return this.stack.push(m),this}}const Jm={min:0,max:0},Im={min:1,max:1};function Pm(m){if(Array.isArray(m)){let n=1/0,a=0;for(const i of m){const m=Pm(i);m&&(n=Math.min(n,m.min),a=Math.max(a,m.max))}return n>a?void 0:{min:n,max:a}}switch(m.type){case"Alternation":case"Expression":return Pm(m.alternatives);case"Assertion":return Jm;case"CharacterClass":return m.characters.isEmpty?void 0:Im;case"Concatenation":{let n=0,a=0;for(const i of m.elements){const m=Pm(i);if(!m)return;n+=m.min,a+=m.max}return{min:n,max:a}}case"Quantifier":{if(0===m.max)return Jm;const n=Pm(m.alternatives);return n?0===n.max?Jm:{min:n.min*m.min,max:n.max*m.max}:0===m.min?Jm:void 0}case"Unknown":return;default:throw h(m)}}const Lm={min:0,max:0,assertMax:0},Mm={min:1,max:1,assertMax:1};function Fm(m,n){if(Array.isArray(m)){let a=1/0,i=0,x=0;for(const e of m){const m=Fm(e,n);m&&(a=Math.min(a,m.min),i=Math.max(i,m.max),x=Math.max(x,m.assertMax))}return a>i?void 0:{min:a,max:i,assertMax:x}}switch(m.type){case"Alternation":case"Expression":return Fm(m.alternatives,n);case"Assertion":return m.kind===n?Fm(m.alternatives,n):Lm;case"CharacterClass":return m.characters.isEmpty?void 0:Mm;case"Concatenation":{let a=0,i=0,x=0;for(const e of m.elements){const m=Fm(e,n);if(!m)return;x=Math.max(x,i+m.assertMax),a+=m.min,i+=m.max}return{min:a,max:i,assertMax:x}}case"Quantifier":{if(0===m.max)return Lm;const a=Fm(m.alternatives,n);if(!a)return 0===m.min?Lm:void 0;if(0===a.max)return Lm;const i=a.max*m.max;return{min:a.min*m.min,max:i,assertMax:i+a.assertMax===1/0?1/0:i+a.assertMax-a.max}}case"Unknown":return;default:throw h(m)}}function Tm(m){return"ltr"===m||"ahead"===m?"ltr":"rtl"}function Dm(m){return"ltr"===m||"ahead"===m?"rtl":"ltr"}function Bm(m,n,a){if(Array.isArray(m))return Rm(m.map((m=>Bm(m,n,a))),a);switch(m.type){case"Alternation":case"Expression":return Bm(m.alternatives,n,a);case"Assertion":if(Tm(m.kind)===n){if(m.negate){if(Em(m,(n=>n!==m&&"Assertion"===n.type)))return i();const e=Bm(m.alternatives,n,a),t=Pm(m.alternatives);return e.empty||!t?{char:I.empty(a),empty:!1,exact:!0}:e.exact&&1===t.max?x({char:e.char.negate(),edge:!0,exact:!0}):i()}return x(jm(Bm(m.alternatives,n,a)))}return i();case"CharacterClass":return{char:m.characters,empty:!1,exact:!0};case"Concatenation":{let i=m.elements;return"rtl"===n&&(i=[...i],i